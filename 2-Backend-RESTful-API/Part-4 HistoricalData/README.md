# Historical Data Documentation
In the folder Models, create a table to store historical data, named HistoricalData.cs.
```cs
using System;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace phase_2_back_end.Models
{
	public class HistoricalData
	{
        [Required]
        [DatabaseGenerated(DatabaseGeneratedOption.Identity)]
        [Key]
        public int Id { get; set; }

        // Name of table that is changed
		    public string TableName { get; set; }
        // Time when SaveChangesAsync() is called in UpdateCell()
        public DateTime DateTime { get; set; }
        // Id of the item changed
        public string KeyValues { get; set; }
        // Old value of the item changed
        public string OldValues { get; set; }
        // New value of the item changed
        public string NewValues { get; set; }
    }
}
```

In the ApplicationDatabase.cs, add this table getter and setter:
```cs
public DbSet<HistoricalData> HistoricalData { get; set; }
```

And in the OnModelCreating(), we set the HistoricalData table to generate a new unique ID whenever we add a new item.
```cs
protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            modelBuilder.Entity<HistoricalData>()
                .Property(p => p.Id)
                .ValueGeneratedOnAdd();
        }
```

Then use migration to update database with the following commands in Package Manager Console:
```
Add-Migration add_HistoricalData_table
Update-Database
```

In the ApplicationDatabase.cs, we will override the SaveChangesAsync() function, which is used in UpdateCell() (in CanvasController.cs). We will wrap around this SaveChangesAsync() a OnBeforeSaveChanges() and a OnAfterSaveChanges().
* The OnBeforeSaveChanges() will grab the old values before change and new values after change. Then save them into the HistoricalData table. At this step we still have some unknown properties for the changing entries, we will return those as a List of HistoricalDataEntry and pass them to the OnAfterSaveChanges().
* The OnAfterSaveChanges() will get the final value of the temporary properties and save it to the HistoricalData table.

Firstly, we will need to create a HistoricalDataEntry object which will contain the changing values we would use during the process.
In folder Models, we create a class  named HistoricalDataEntry.cs
```cs
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Linq;

namespace phase_2_back_end.Models
{
	public class HistoricalDataEntry
	{
        public HistoricalDataEntry(EntityEntry entry)
        {
            Entry = entry;
        }
        public EntityEntry Entry { get; }
        public string TableName { get; set; }
        public Dictionary<string, object> KeyValues { get; } = new Dictionary<string, object>();
        public Dictionary<string, object> OldValues { get; } = new Dictionary<string, object>();
        public Dictionary<string, object> NewValues { get; } = new Dictionary<string, object>();
        public List<PropertyEntry> TemporaryProperties { get; } = new List<PropertyEntry>();

        public bool HasTemporaryProperties => TemporaryProperties.Any();

        public HistoricalData ToHistoricalData()
        {
            var historicalData = new HistoricalData();
            historicalData.TableName = TableName;
            historicalData.DateTime = DateTime.UtcNow;
            historicalData.KeyValues = JsonConvert.SerializeObject(KeyValues);
            historicalData.OldValues = OldValues.Count == 0 ? null : JsonConvert.SerializeObject(OldValues);
            historicalData.NewValues = NewValues.Count == 0 ? null : JsonConvert.SerializeObject(NewValues);
            return historicalData;
        }
    }
}
```

After that, we will build the 2 functions OnBeforeSaveChanges() and OnAfterSaveChanges() in `ApplicationDatabase.cs`

* `OnBeforeSaveChanges()`
```cs
		private List<HistoricalDataEntry> OnBeforeSaveChanges()
        {
            ChangeTracker.DetectChanges();
            var historicalDataEntries = new List<HistoricalDataEntry>();
            foreach (var entry in ChangeTracker.Entries())
            {
                if (entry.Entity is HistoricalData || entry.State == EntityState.Detached || entry.State == EntityState.Unchanged)
                    continue;

                var historicalDataEntry = new HistoricalDataEntry(entry);
                historicalDataEntry.TableName = entry.Metadata.GetTableName();
                historicalDataEntries.Add(historicalDataEntry);

                foreach (var property in entry.Properties)
                {
                    if (property.IsTemporary)
                    {
                        // value will be generated by the database, get the value after saving
                        historicalDataEntry.TemporaryProperties.Add(property);
                        continue;
                    }

                    string propertyName = property.Metadata.Name;
                    if (property.Metadata.IsPrimaryKey())
                    {
                        historicalDataEntry.KeyValues[propertyName] = property.CurrentValue;
                        continue;
                    }

                    switch (entry.State)
                    {
                        case EntityState.Added:
                            historicalDataEntry.NewValues[propertyName] = property.CurrentValue;
                            break;

                        case EntityState.Deleted:
                            historicalDataEntry.OldValues[propertyName] = property.OriginalValue;
                            break;

                        case EntityState.Modified:
                            if (property.IsModified)
                            {
                                historicalDataEntry.OldValues[propertyName] = property.OriginalValue;
                                historicalDataEntry.NewValues[propertyName] = property.CurrentValue;
                            }
                            break;
                    }
                }
            }

            // Save historical data entities that have all the modifications
            foreach (var historicalDataEntry in historicalDataEntries.Where(_ => !_.HasTemporaryProperties))
            {
                HistoricalData.Add(historicalDataEntry.ToHistoricalData());
            }

            // keep a list of entries where the value of some properties are unknown at this step
            return historicalDataEntries.Where(_ => _.HasTemporaryProperties).ToList();
        }
```

* `OnAfterSaveChanges()`
```cs
		private Task OnAfterSaveChanges(List<HistoricalDataEntry> historicalDataEntries)
        {
            if (historicalDataEntries == null || historicalDataEntries.Count == 0)
            {
                return Task.CompletedTask;
            }

            foreach (var historicalDataEntry in historicalDataEntries)
            {
                // Get the final value of the temporary properties
                foreach (var prop in historicalDataEntry.TemporaryProperties)
                {
                    if (prop.Metadata.IsPrimaryKey())
                    {
                        historicalDataEntry.KeyValues[prop.Metadata.Name] = prop.CurrentValue;
                    }
                    else
                    {
                        historicalDataEntry.NewValues[prop.Metadata.Name] = prop.CurrentValue;
                    }
                }

                // Save the Historical entry
                HistoricalData.Add(historicalDataEntry.ToHistoricalData());
            }
            return SaveChangesAsync();
        }
```

Finally, we will override the SaveChangesAsync() with the two functions above.
```cs
public override async Task<int> SaveChangesAsync(bool acceptAllChangesOnSuccess, CancellationToken cancellationToken = default(CancellationToken))
		{
			var historicalDataEntries = OnBeforeSaveChanges();
			var result = await base.SaveChangesAsync(acceptAllChangesOnSuccess, cancellationToken);
			await OnAfterSaveChanges(historicalDataEntries);
			return result;
		}
```

Now we will make some endpoints that will be needed for the front-end to use.
Firstly, we create an endpoint to grab all data from HistoricalData table, which we just have built. In the Controllers folder, create a controller named `HistoricalDatasController.cs`
```cs
using Microsoft.AspNetCore.Mvc;
using System.Collections.Generic;
using System.Threading.Tasks;
using phase_2_back_end.Models;
using Microsoft.EntityFrameworkCore;

namespace phase_2_back_end.Controllers
{
	[Route("api/[controller]")]
	[ApiController]
	public class HistoricalDatasController : ControllerBase
	{
        private readonly ApplicationDatabase _context;

        public HistoricalDatasController(ApplicationDatabase context)
        {
            _context = context;
        }

        // GET: api/HistoricalData
        [HttpGet]
        public async Task<ActionResult<IEnumerable<HistoricalData>>> GetHistoricalData()
        {
            return await _context.HistoricalData.ToListAsync();
        }
    }
}
```

Secondly, we need an API to get the latest version of Canvas using its ID.
`CanvasController.cs`
```cs
[HttpGet("{id}")]
        public async Task<ActionResult<Canvas>> GetCanvasById(int id)
        {
            var canvas = await _context.Canvas
                .Include(c => c.ColorData)
                .FirstOrDefaultAsync(c => c.CanvasID == id);

            if (canvas == null)
            {
                return NotFound();
            }
            return canvas;
        }
```
Finally, we will create an endpoint to get the color cell, i.e. ColorData, using its ID. In folder Controllers, we create a controller named ColorDatasController.cs. It will have a GET method to grab the ColorData item by its ID.
```cs
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using phase_2_back_end.Models;

namespace phase_2_back_end.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    public class ColorDatasController : ControllerBase
    {
        private readonly ApplicationDatabase _context;

        public ColorDatasController(ApplicationDatabase context)
        {
            _context = context;
        }

        // GET: api/ColorDatas/5
        [HttpGet("{id}")]
        public async Task<ActionResult<ColorData>> GetColorData(int id)
        {
            var colorData = await _context.ColorData.FindAsync(id);

            if (colorData == null)
            {
                return NotFound();
            }

            return colorData;
        }
    }
}
```
